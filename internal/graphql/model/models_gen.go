// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"bytes"
	"fmt"
	"io"
	"strconv"
	"time"

	"github.com/b-sea/supply-run-api/internal/entity"
)

type Node interface {
	IsNode()
	GetID() ID
}

type RecipeResult interface {
	IsRecipeResult()
}

type UnitResult interface {
	IsUnitResult()
}

type UserResult interface {
	IsUserResult()
}

type Ingredient struct {
	Name     string     `json:"name"`
	Quantity float64    `json:"quantity"`
	Unit     UnitResult `json:"unit"`
	UnitID   entity.ID  `json:"-"`
}

type NotFoundError struct {
	ID ID `json:"id"`
}

func (NotFoundError) IsNode()        {}
func (this NotFoundError) GetID() ID { return this.ID }

func (NotFoundError) IsRecipeResult() {}

func (NotFoundError) IsUnitResult() {}

func (NotFoundError) IsUserResult() {}

type Order struct {
	Sort      *Sort      `json:"Sort,omitempty"`
	Direction *Direction `json:"Direction,omitempty"`
}

type Page struct {
	First *int    `json:"first,omitempty"`
	After *Cursor `json:"after,omitempty"`
}

type PageInfo struct {
	HasNextPage     bool    `json:"hasNextPage"`
	HasPreviousPage bool    `json:"hasPreviousPage"`
	StartCursor     *Cursor `json:"startCursor,omitempty"`
	EndCursor       *Cursor `json:"endCursor,omitempty"`
}

type Query struct {
}

type Recipe struct {
	ID          ID            `json:"id"`
	Name        string        `json:"name"`
	URL         string        `json:"url"`
	NumServings int           `json:"numServings"`
	Steps       []string      `json:"steps"`
	Ingredients []*Ingredient `json:"ingredients"`
	Tags        []string      `json:"tags"`
	IsFavorite  bool          `json:"isFavorite"`
	CreatedAt   time.Time     `json:"createdAt"`
	CreatedBy   UserResult    `json:"createdBy"`
	UpdatedAt   time.Time     `json:"updatedAt"`
	UpdatedBy   UserResult    `json:"updatedBy"`
	CreatedByID entity.ID     `json:"-"`
	UpdatedByID entity.ID     `json:"-"`
}

func (Recipe) IsNode()        {}
func (this Recipe) GetID() ID { return this.ID }

func (Recipe) IsRecipeResult() {}

type RecipeConnection struct {
	PageInfo *PageInfo     `json:"pageInfo"`
	Edges    []*RecipeEdge `json:"edges"`
}

type RecipeEdge struct {
	Cursor Cursor  `json:"cursor"`
	Node   *Recipe `json:"node"`
}

type RecipeFilter struct {
	Name        *string  `json:"name,omitempty"`
	Ingredients []string `json:"ingredients,omitempty"`
	CreatedBy   *ID      `json:"createdBy,omitempty"`
	IsFavorite  *bool    `json:"isFavorite,omitempty"`
}

type Unit struct {
	ID       ID     `json:"id"`
	Name     string `json:"name"`
	Symbol   string `json:"symbol"`
	BaseType string `json:"baseType"`
	System   string `json:"system"`
}

func (Unit) IsNode()        {}
func (this Unit) GetID() ID { return this.ID }

func (Unit) IsUnitResult() {}

type User struct {
	ID       ID     `json:"id"`
	Username string `json:"username"`
}

func (User) IsNode()        {}
func (this User) GetID() ID { return this.ID }

func (User) IsUserResult() {}

type Direction string

const (
	DirectionDesc Direction = "DESC"
	DirectionAsc  Direction = "ASC"
)

var AllDirection = []Direction{
	DirectionDesc,
	DirectionAsc,
}

func (e Direction) IsValid() bool {
	switch e {
	case DirectionDesc, DirectionAsc:
		return true
	}
	return false
}

func (e Direction) String() string {
	return string(e)
}

func (e *Direction) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Direction(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Direction", str)
	}
	return nil
}

func (e Direction) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *Direction) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e Direction) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type Sort string

const (
	SortCreated Sort = "CREATED"
	SortUpdated Sort = "UPDATED"
	SortName    Sort = "NAME"
)

var AllSort = []Sort{
	SortCreated,
	SortUpdated,
	SortName,
}

func (e Sort) IsValid() bool {
	switch e {
	case SortCreated, SortUpdated, SortName:
		return true
	}
	return false
}

func (e Sort) String() string {
	return string(e)
}

func (e *Sort) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Sort(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Sort", str)
	}
	return nil
}

func (e Sort) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *Sort) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e Sort) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}
